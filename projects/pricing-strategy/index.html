<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Pricing Competition | Ruize Hou</title><meta name=keywords content><meta name=description content="Pricing Competition Introduction The purpose of this project was to participate in a class pricing competition based on the previous knowledge of demand estimation, revenue maximization, and pricing learned from the class. The project consists of two parts. Part one requires our team to come up with a pricing strategy based on the user valuation of an arbitrary product, opponent price, and history of sale. Part two requires our team to train a machine learning model and complete the tasks of demand estimation based on three user covariants, and revenue maximization to output the optimal price."><meta name=author content="Ruize Hou, Shibo Xu, Novia Wu"><link rel=canonical href=https://horizonhou.github.io/projects/pricing-strategy/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://horizonhou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://horizonhou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://horizonhou.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://horizonhou.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://horizonhou.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Pricing Competition"><meta property="og:description" content="Pricing Competition Introduction The purpose of this project was to participate in a class pricing competition based on the previous knowledge of demand estimation, revenue maximization, and pricing learned from the class. The project consists of two parts. Part one requires our team to come up with a pricing strategy based on the user valuation of an arbitrary product, opponent price, and history of sale. Part two requires our team to train a machine learning model and complete the tasks of demand estimation based on three user covariants, and revenue maximization to output the optimal price."><meta property="og:type" content="article"><meta property="og:url" content="https://horizonhou.github.io/projects/pricing-strategy/"><meta property="og:image" content="https://horizonhou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="projects"><meta property="article:published_time" content="2022-12-19T23:15:00+07:00"><meta property="article:modified_time" content="2022-12-19T23:15:00+07:00"><meta property="og:site_name" content="RuizeHou"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://horizonhou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Pricing Competition"><meta name=twitter:description content="Pricing Competition Introduction The purpose of this project was to participate in a class pricing competition based on the previous knowledge of demand estimation, revenue maximization, and pricing learned from the class. The project consists of two parts. Part one requires our team to come up with a pricing strategy based on the user valuation of an arbitrary product, opponent price, and history of sale. Part two requires our team to train a machine learning model and complete the tasks of demand estimation based on three user covariants, and revenue maximization to output the optimal price."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"https://horizonhou.github.io/projects/"},{"@type":"ListItem","position":2,"name":"Pricing Competition","item":"https://horizonhou.github.io/projects/pricing-strategy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Pricing Competition","name":"Pricing Competition","description":"Pricing Competition Introduction The purpose of this project was to participate in a class pricing competition based on the previous knowledge of demand estimation, revenue maximization, and pricing learned from the class. The project consists of two parts. Part one requires our team to come up with a pricing strategy based on the user valuation of an arbitrary product, opponent price, and history of sale. Part two requires our team to train a machine learning model and complete the tasks of demand estimation based on three user covariants, and revenue maximization to output the optimal price.","keywords":[],"articleBody":"Pricing Competition Introduction The purpose of this project was to participate in a class pricing competition based on the previous knowledge of demand estimation, revenue maximization, and pricing learned from the class. The project consists of two parts. Part one requires our team to come up with a pricing strategy based on the user valuation of an arbitrary product, opponent price, and history of sale. Part two requires our team to train a machine learning model and complete the tasks of demand estimation based on three user covariants, and revenue maximization to output the optimal price. Then based on this optimal price, we combine our strategy from part one to compete for customers. Each game will consist of two teams bidding prices for one customer without capacity constraints, the team with lower price under the valuation will win that round and gain revenue. Overall, the team with the most revenue across games will win the competition. As a result, we need to anticipate the moves of the opponent, and handle different situations with our algorithm.\nSpecific techniques and strategies will be discussed extensively in the report below.\nA: Demand estimation and price optimization (without competition) For part two, demand estimation and price optimization, our goal was to train a machine learning model and complete the tasks of demand estimation based on three user covariants, and do revenue maximization to output the optimal price. Then based on this optimal price, we combine our strategy from part one to compete for customers. Find Price Set and demand estimation We built a logistic regression model, whose input was covariates and prices, and the output was -1, 0 or 1, which represented which item users bought. We trained the model using all the training data and got the demand result by using predict_proba(). We wanted to find a set of prices which can be used in the calculation of max revenue. Thus, we plotted the demand curves of item_0 and item_1 which are shown below. We found that in the training set, for both item_0 and item_1, when the price goes larger than 30, the demand decreases to almost 0. Therefore, we set the price range to 0.1 to 30. We finally sampled prices from 0.1 to 30 in intervals of 0.1 and got a price set with a size of 89401, the price set is shown below. Models and price optimization LogisticRegression Logistic Regression performed well overall with an average per-customer runtime of 0.271 second. It also beat the dummy_fixed_prices_adaptive agent with T =2500, with a total profit of nearly 4000. All models were run against the dummy_fixed_prices_adaptive agent as a benchmark because we assume the opponent will be playing rationally most of the time, like this adaptive agent. Also other more advanced agents were not available for testing, so we compared our performance with this agent. Random Forest Random Forest performed better than Logistic Regression but with an average per-customer runtime of 0.45 second. It didn’t beat the dummy_fixed_prices_adaptive agent with T =2500, with a total profit of nearly 4500. In addition, the size of the random forest model is large, more than 30 Mb. KNN KNN performed best among the three models but with a much longer average per-customer runtime of 1.78 second. It didn’t beat the dummy_fixed_prices_adaptive agent with T =2500, with a total profit of over 5000. Due to the time complexity of the KNN model, we chose not to proceed with this approach. Final Model: LogisticRegression In our final model, we used logistics regression to predict the customer’s valuation for the two products. Even though the test accuracy of logistic regression was not as high as that of Random Forest, we still picked logistic regression since it gave us an acceptable accuracy and it took way less time than Random Forest to compute the customer covariates. In the contest, we had 500 mm for each step. We recorded the time for logistic regression and Random Forest, and we found that logistic regression is safely within the time requirement, but Random Forest was on the edge of time limit. To be conservative, we chose logistic regression to achieve a safer run time.\nB: Pricing under competition For part one, we utilize the user valuation of each item for each game. We also observe the price the opponent gave and who the customer bought from the last round. From there we needed to anticipate the pricing strategy of the opponent and come up with our own pricing strategy that would ultimately produce the highest revenue.\nFinal Strategy for part 1: Dynamic Pricing based on Opponent Strategy During one of the trial runs, we got negative revenue results. This could potentially be due to opponents playing evil and setting prices ridiculously high, or give negative prices occasionally, and skew our ɑ such that it becomes negative and we keep giving negative prices. This will result in a infinite loop of “winning” the customer because our price is lower, and it keeps lowering our ɑ, we then accumulate negative revenue. To combat this evil behavior and other similar behaviors, we implemented a series of steps that combines the best ideas from the previous iterations to ensure the best strategy:\nSet a high price (close to valuation) on the first round. This is to set up the tone for cooperative play. Set up a checkpoint at round 100 to see if the opponent has been playing rational or not. We check by reverse engineering out the ɑ they could potentially be using. If their ɑ\u003c0.5, we consider them playing evil and set our ɑ to 70% of theirs. Every 100 rounds, reset ɑ if the team is playing nice. This strategy is used to prevent price war as well as increase opponent’s ɑ as discussed above. When the valuation \u003c 5, we return a crazy high price and let the opponent win that round while throwing them off. This strategy was discussed in the previous iteration. For all other rounds, we check if the team is playing evil: ** Evil: when opponent’s last ɑ is too high (\u003e1) or too low (\u003c=0.85), or if their ɑ changed too dramatically from the round before the last round. ** Not evil: when the opponent is playing rationally, not satisfying above criteria. When the opponent is playing evil, we play adaptively, only adjust the price based on our own previous prices using self-adjusting ɑ like previous iterations. When the opponent is playing rationally, we play tit-for-tat, we learn opponent’s previous ɑ and setting it as the β value, then undercut them by 0.9. Below are the results for running the final algorithm ThreeHonestMerchant against the dummy_fixed_prices_adaptive agent and the previous iterations, T = 2500. Based on these local running results, we were confident about our performance on the pricing strategy. Our algorithm consistently outperformed other competitor iterations and the template competitors given. However, there could be more sophisticated ways to play the game that we have not considered yet, and that might be our blindspot where our algorithm will have a hard time competing against. Below is a table for the official competition result of part one of the final project. We ended up being ranked 12th amongst the 24 teams of students, dummy agents, and teaching staff. We did not perform as well as we anticipated, likely due to the fact that we have not considered all the different ways the opponent could play. Our average revenue per game was around 3868, which is consistent with our local run against the dummy_fixed_prices_adaptive agent. By checking the official result head to toe (the log of each game), we realized that our revenue is not consistent across different opponents. This means that if the opponent is playing a game such that it will drive a price war or prevent both sides from gaining the maximum profit possible, we don’t have mechanisms to prevent that and gain stable revenue when the other player is driving down the prices. However, in a real market sense, it’s hard to compete with competitors who keep giving low prices. This kind of competition is unhealthy for the market and both sides will end up not gaining much revenue. After the final result and moving forward to the second part, where we need to combine demand estimation and revenue maximization with the competition element, we decided to keep the majority of the logic and make small tweaks to the coefficients to hopefully gain more revenue.\nFinal Strategy for Part 2: We followed the same strategy in Part 1, with some modifications to adjust for the new two-item scenario and improve the strategy performance in Part 1: Since we did not have the customer valuation, we set our prediction as customer valuation Due to the presence of two items, and the fact that the customer will only choose one item to buy, we set an incredibly high price if the valuation for both of the two items for the current customer is lower than 5. We realized this scenario is slightly different from Part 1, because the probability of having a valuation lower than 5 for one item is much larger than the probability of having two lower than 5 valuations for one customer. Even though there are two items, we estimate our opponent’s ɑ just based on the sold item. Because we thought that the sold item best reflected the opponent’s strategy. We changed the evaluation metric of whether the opponent is playing as a good merchant to be more sensitive. Before, we took the mean of the whole set of ɑ for our opponent to check for their behavior. However, we thought our opponent may not pursue a consistent strategy the whole time. It was highly possible that they would change their strategy based on our behavior or simply as time went over. So we decided to take the mean the most recent 20 ɑ to check for their behavior. This approach to some extent eliminated the noise from previous behaviors and just focused on their current strategy. We returned pricing for the two items using our predicted valuation multiplied by the same ɑ (our factor). This method will automatically lead the customer to buy the more expensive item. Because: Predicted valuation: V1 and V2 Our Price:\tP1 = V1ɑ and P2 = V2ɑ Customer buys neither item if: V1\u003c P1 and V2","wordCount":"2195","inLanguage":"en","datePublished":"2022-12-19T23:15:00+07:00","dateModified":"2022-12-19T23:15:00+07:00","author":[{"@type":"Person","name":"Ruize Hou"},{"@type":"Person","name":"Shibo Xu"},{"@type":"Person","name":"Novia Wu"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://horizonhou.github.io/projects/pricing-strategy/"},"publisher":{"@type":"Organization","name":"Ruize Hou","logo":{"@type":"ImageObject","url":"https://horizonhou.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://horizonhou.github.io/ accesskey=h title="Ruize Hou (Alt + H)"><img src=https://horizonhou.github.io/images/data-science.png alt=logo aria-label=logo height=35>Ruize Hou</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://horizonhou.github.io/about/ title=About><span>About</span></a></li><li><a href=https://horizonhou.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://horizonhou.github.io/blogs/ title=Blogs><span>Blogs</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://horizonhou.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://horizonhou.github.io/projects/>Projects</a></div><h1 class=post-title>Pricing Competition</h1><div class=post-meta><span title='2022-12-19 23:15:00 +0700 +0700'>December 19, 2022</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Ruize Hou, Shibo Xu, Novia Wu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#pricing-competition aria-label="Pricing Competition">Pricing Competition</a></li><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#a-demand-estimation-and-price-optimization-without-competition aria-label="A: Demand estimation and price optimization (without competition)">A: Demand estimation and price optimization (without competition)</a><ul><ul><li><a href=#find-price-set-and-demand-estimation aria-label="Find Price Set and demand estimation">Find Price Set and demand estimation</a></li><li><a href=#models-and-price-optimization aria-label="Models and price optimization">Models and price optimization</a><ul><li><a href=#logisticregression aria-label=LogisticRegression>LogisticRegression</a></li><li><a href=#random-forest aria-label="Random Forest">Random Forest</a></li><li><a href=#knn aria-label=KNN>KNN</a></li></ul></li><li><a href=#final-model-logisticregression aria-label="Final Model: LogisticRegression">Final Model: LogisticRegression</a></li></ul></ul></li><li><a href=#b-pricing-under-competition aria-label="B: Pricing under competition">B: Pricing under competition</a><ul><ul><li><a href=#final-strategy-for-part-1-dynamic-pricing-based-on-opponent-strategy aria-label="Final Strategy for part 1: Dynamic Pricing based on Opponent Strategy">Final Strategy for part 1: Dynamic Pricing based on Opponent Strategy</a></li><li><a href=#final-strategy-for-part-2 aria-label="Final Strategy for Part 2:">Final Strategy for Part 2:</a></li></ul></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><h1 id=pricing-competition>Pricing Competition<a hidden class=anchor aria-hidden=true href=#pricing-competition>#</a></h1><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p>The purpose of this project was to participate in a class pricing competition based on the previous knowledge of demand estimation, revenue maximization, and pricing learned from the class. The project consists of two parts. Part one requires our team to come up with a pricing strategy based on the user valuation of an arbitrary product, opponent price, and history of sale. Part two requires our team to train a machine learning model and complete the tasks of demand estimation based on three user covariants, and revenue maximization to output the optimal price. Then based on this optimal price, we combine our strategy from part one to compete for customers. Each game will consist of two teams bidding prices for one customer without capacity constraints, the team with lower price under the valuation will win that round and gain revenue. Overall, the team with the most revenue across games will win the competition. As a result, we need to anticipate the moves of the opponent, and handle different situations with our algorithm.</p><p>Specific techniques and strategies will be discussed extensively in the report below.</p><h1 id=a-demand-estimation-and-price-optimization-without-competition>A: Demand estimation and price optimization (without competition)<a hidden class=anchor aria-hidden=true href=#a-demand-estimation-and-price-optimization-without-competition>#</a></h1><p>For part two, demand estimation and price optimization, our goal was to train a machine learning model and complete the tasks of demand estimation based on three user covariants, and do revenue maximization to output the optimal price. Then based on this optimal price, we combine our strategy from part one to compete for customers.</p><h3 id=find-price-set-and-demand-estimation>Find Price Set and demand estimation<a hidden class=anchor aria-hidden=true href=#find-price-set-and-demand-estimation>#</a></h3><p>We built a logistic regression model, whose input was covariates and prices, and the output was -1, 0 or 1, which represented which item users bought. We trained the model using all the training data and got the demand result by using predict_proba().
We wanted to find a set of prices which can be used in the calculation of max revenue. Thus, we plotted the demand curves of item_0 and item_1 which are shown below. We found that in the training set, for both item_0 and item_1, when the price goes larger than 30, the demand decreases to almost 0. Therefore, we set the price range to 0.1 to 30.
<img loading=lazy src=/images/Pricing/data_dis.png alt=image1>
We finally sampled prices from 0.1 to 30 in intervals of 0.1 and got a price set with a size of 89401, the price set is shown below.
<img loading=lazy src=/images/Pricing/data_dis1.png alt=image1></p><h3 id=models-and-price-optimization>Models and price optimization<a hidden class=anchor aria-hidden=true href=#models-and-price-optimization>#</a></h3><h4 id=logisticregression>LogisticRegression<a hidden class=anchor aria-hidden=true href=#logisticregression>#</a></h4><p><img loading=lazy src=/images/Pricing/logistic_regression.png alt=image1>
Logistic Regression performed well overall with an average per-customer runtime of 0.271 second. It also beat the dummy_fixed_prices_adaptive agent with T =2500, with a total profit of nearly 4000. All models were run against the dummy_fixed_prices_adaptive agent as a benchmark because we assume the opponent will be playing rationally most of the time, like this adaptive agent. Also other more advanced agents were not available for testing, so we compared our performance with this agent.</p><h4 id=random-forest>Random Forest<a hidden class=anchor aria-hidden=true href=#random-forest>#</a></h4><p><img loading=lazy src=/images/Pricing/random_forest.png alt=image1>
Random Forest performed better than Logistic Regression but with an average per-customer runtime of 0.45 second. It didn’t beat the dummy_fixed_prices_adaptive agent with T =2500, with a total profit of nearly 4500. In addition, the size of the random forest model is large, more than 30 Mb.</p><h4 id=knn>KNN<a hidden class=anchor aria-hidden=true href=#knn>#</a></h4><p><img loading=lazy src=/images/Pricing/knn.png alt=image1>
KNN performed best among the three models but with a much longer average per-customer runtime of 1.78 second. It didn’t beat the dummy_fixed_prices_adaptive agent with T =2500, with a total profit of over 5000. Due to the time complexity of the KNN model, we chose not to proceed with this approach.</p><h3 id=final-model-logisticregression>Final Model: LogisticRegression<a hidden class=anchor aria-hidden=true href=#final-model-logisticregression>#</a></h3><p>In our final model, we used logistics regression to predict the customer’s valuation for the two products. Even though the test accuracy of logistic regression was not as high as that of Random Forest, we still picked logistic regression since it gave us an acceptable accuracy and it took way less time than Random Forest to compute the customer covariates. In the contest, we had 500 mm for each step. We recorded the time for logistic regression and Random Forest, and we found that logistic regression is safely within the time requirement, but Random Forest was on the edge of time limit. To be conservative, we chose logistic regression to achieve a safer run time.</p><h1 id=b-pricing-under-competition>B: Pricing under competition<a hidden class=anchor aria-hidden=true href=#b-pricing-under-competition>#</a></h1><p>For part one, we utilize the user valuation of each item for each game. We also observe the price the opponent gave and who the customer bought from the last round. From there we needed to anticipate the pricing strategy of the opponent and come up with our own pricing strategy that would ultimately produce the highest revenue.</p><h3 id=final-strategy-for-part-1-dynamic-pricing-based-on-opponent-strategy>Final Strategy for part 1: Dynamic Pricing based on Opponent Strategy<a hidden class=anchor aria-hidden=true href=#final-strategy-for-part-1-dynamic-pricing-based-on-opponent-strategy>#</a></h3><p>During one of the trial runs, we got negative revenue results. This could potentially be due to opponents playing evil and setting prices ridiculously high, or give negative prices occasionally, and skew our ɑ such that it becomes negative and we keep giving negative prices. This will result in a infinite loop of “winning” the customer because our price is lower, and it keeps lowering our ɑ, we then accumulate negative revenue.</p><p>To combat this evil behavior and other similar behaviors, we implemented a series of steps that combines the best ideas from the previous iterations to ensure the best strategy:</p><ul><li>Set a high price (close to valuation) on the first round. This is to set up the tone for cooperative play.</li><li>Set up a checkpoint at round 100 to see if the opponent has been playing rational or not. We check by reverse engineering out the ɑ they could potentially be using. If their ɑ&lt;0.5, we consider them playing evil and set our ɑ to 70% of theirs.</li><li>Every 100 rounds, reset ɑ if the team is playing nice. This strategy is used to prevent price war as well as increase opponent’s ɑ as discussed above.</li><li>When the valuation &lt; 5, we return a crazy high price and let the opponent win that round while throwing them off. This strategy was discussed in the previous iteration.</li><li>For all other rounds, we check if the team is playing evil:
** Evil: when opponent’s last ɑ is too high (>1) or too low (&lt;=0.85), or if their ɑ changed too dramatically from the round before the last round.
** Not evil: when the opponent is playing rationally, not satisfying above criteria.</li><li>When the opponent is playing evil, we play adaptively, only adjust the price based on our own previous prices using self-adjusting ɑ like previous iterations.</li><li>When the opponent is playing rationally, we play tit-for-tat, we learn opponent’s previous ɑ and setting it as the β value, then undercut them by 0.9.</li></ul><p>Below are the results for running the final algorithm ThreeHonestMerchant against the dummy_fixed_prices_adaptive agent and the previous iterations, T = 2500.
<img loading=lazy src=/images/Pricing/profit.png alt=image1>
Based on these local running results, we were confident about our performance on the pricing strategy. Our algorithm consistently outperformed other competitor iterations and the template competitors given. However, there could be more sophisticated ways to play the game that we have not considered yet, and that might be our blindspot where our algorithm will have a hard time competing against.
Below is a table for the official competition result of part one of the final project. We ended up being ranked 12th amongst the 24 teams of students, dummy agents, and teaching staff.
<img loading=lazy src=/images/Pricing/result1_1.png alt=image1>
We did not perform as well as we anticipated, likely due to the fact that we have not considered all the different ways the opponent could play. Our average revenue per game was around 3868, which is consistent with our local run against the dummy_fixed_prices_adaptive agent. By checking the official result head to toe (the log of each game), we realized that our revenue is not consistent across different opponents. This means that if the opponent is playing a game such that it will drive a price war or prevent both sides from gaining the maximum profit possible, we don’t have mechanisms to prevent that and gain stable revenue when the other player is driving down the prices. However, in a real market sense, it’s hard to compete with competitors who keep giving low prices. This kind of competition is unhealthy for the market and both sides will end up not gaining much revenue.
After the final result and moving forward to the second part, where we need to combine demand estimation and revenue maximization with the competition element, we decided to keep the majority of the logic and make small tweaks to the coefficients to hopefully gain more revenue.</p><h3 id=final-strategy-for-part-2>Final Strategy for Part 2:<a hidden class=anchor aria-hidden=true href=#final-strategy-for-part-2>#</a></h3><ul><li>We followed the same strategy in Part 1, with some modifications to adjust for the new two-item scenario and improve the strategy performance in Part 1:
Since we did not have the customer valuation, we set our prediction as customer valuation
Due to the presence of two items, and the fact that the customer will only choose one item to buy, we set an incredibly high price if the valuation for both of the two items for the current customer is lower than 5. We realized this scenario is slightly different from Part 1, because the probability of having a valuation lower than 5 for one item is much larger than the probability of having two lower than 5 valuations for one customer.</li><li>Even though there are two items, we estimate our opponent’s ɑ just based on the sold item. Because we thought that the sold item best reflected the opponent&rsquo;s strategy.</li><li>We changed the evaluation metric of whether the opponent is playing as a good merchant to be more sensitive. Before, we took the mean of the whole set of ɑ for our opponent to check for their behavior. However, we thought our opponent may not pursue a consistent strategy the whole time. It was highly possible that they would change their strategy based on our behavior or simply as time went over. So we decided to take the mean the most recent 20 ɑ to check for their behavior. This approach to some extent eliminated the noise from previous behaviors and just focused on their current strategy.</li><li>We returned pricing for the two items using our predicted valuation multiplied by the same ɑ (our factor). This method will automatically lead the customer to buy the more expensive item. Because:</li></ul><p>Predicted valuation: V1 and V2</p><p>Our Price: P1 = V1<em>ɑ and P2 = V2</em>ɑ</p><p>Customer buys neither item if: V1&lt; P1 and V2&lt;P2 (This will not happen because ɑ &lt;= 1)</p><p>Customer buys item 1 if: V1>=P1 and V1 - P1 >= V2 - P2</p><p>If V1 >= V2, then V1 – P1 = V1 – V1<em>ɑ = V1</em>(1-ɑ), V2 – P2 = V2 – V2<em>ɑ = V2</em>(1-ɑ)</p><p>Given V1 >= V2, We have V1*(1-ɑ) >= V2*(1-ɑ), thus V1 – P1 >= V2 – P2</p><p>So Customer will buy item 1 automatically if V1 >= V2, and vice versa</p><p>Besides these modifications, our strategy remained the same as Part 1. Below is the result of the final competition for part two.
<img loading=lazy src=/images/Pricing/result2.png alt=image1>
Our algorithm performed better in part two compared to part one. We hypothesized that it could be due to our enhanced logic for competition, successful demand estimation, and maybe other teams are not performing as well.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>Reflecting on our performance, we were not satisfied with part 1 and were more satisfied with part 2. Like hypothesized above, many factors could have contributed to a better performance in part 2. However, we do hope that we could have run more trials in part 2. We missed most of the trial runs before the final competition due to time limitation and model package error, and wasted time on that instead of developing other models.</p><p>We were glad to catch the price war prevention aspect of the project early on. Price war happens when toxic competition occurs and each competitor is trying to undercut the other by lowering price, especially when there is no product differentiation. We named our team ThreeHonestMerchant because we wanted to do “business” with honesty and choose not to introduce trickery beyond what is rational, and we assume that most of the time the opponent is also playing rationally. However, based on some of the trail competition results, we needed safety nets that can allow us to respond if we do encounter a toxic competitor.</p><p>Another thing we could have done for part 2 demand estimation and price optimization was to deal with potentially missing or biased data. Even though we were not given the characteristics of each of the three user covariate, in real life these covariates could introduce bias to the system and thus create discriminatory individualized pricing for each buyer.</p><p>Overall, the class competition showed that sometimes more sophisticated models (like the KNN and RandomForest we tried) are not necessarily the best model in producing results in a timely manner. We learned that in a pricing competition like this one, factors such as user covariates and valuations, demand estimation, capacity constraints, opponent behavior etc. should be taken into account to produce the best results. This project was a valuable lesson about attention to detail and developing solutions that focus on the right data and interpretations, instead of algorithmic or model sophistication.</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://horizonhou.github.io/projects/logistics-optimization/><span class=title>« Prev Page</span><br><span>Express Air Cargo Optimization</span></a>
<a class=next href=https://horizonhou.github.io/projects/markov-chain/><span class=title>Next Page »</span><br><span>Predicting Citi Bike Availability Using Markov Chains</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Pricing Competition on twitter" href="https://twitter.com/intent/tweet/?text=Pricing%20Competition&amp;url=https%3a%2f%2fhorizonhou.github.io%2fprojects%2fpricing-strategy%2f&amp;hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Pricing Competition on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fhorizonhou.github.io%2fprojects%2fpricing-strategy%2f&amp;title=Pricing%20Competition&amp;summary=Pricing%20Competition&amp;source=https%3a%2f%2fhorizonhou.github.io%2fprojects%2fpricing-strategy%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Pricing Competition on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fhorizonhou.github.io%2fprojects%2fpricing-strategy%2f&title=Pricing%20Competition"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Pricing Competition on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fhorizonhou.github.io%2fprojects%2fpricing-strategy%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Pricing Competition on whatsapp" href="https://api.whatsapp.com/send?text=Pricing%20Competition%20-%20https%3a%2f%2fhorizonhou.github.io%2fprojects%2fpricing-strategy%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Pricing Competition on telegram" href="https://telegram.me/share/url?text=Pricing%20Competition&amp;url=https%3a%2f%2fhorizonhou.github.io%2fprojects%2fpricing-strategy%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://horizonhou.github.io/>Ruize Hou</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>